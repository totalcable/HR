{"remainingRequest":"C:\\xampp\\htdocs\\HRMTIS-live\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\xampp\\htdocs\\HRMTIS-live\\frontend\\node_modules\\ngx-permissions\\ngx-permissions.umd.js","dependencies":[{"path":"C:\\xampp\\htdocs\\HRMTIS-live\\frontend\\node_modules\\ngx-permissions\\ngx-permissions.umd.js","mtime":1565087151191},{"path":"C:\\xampp\\htdocs\\HRMTIS-live\\frontend\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1565087056762},{"path":"C:\\xampp\\htdocs\\HRMTIS-live\\frontend\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1565087014262}],"contextDependencies":[],"result":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('@angular/router')) :\n        typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs', 'rxjs/operators', '@angular/router'], factory) :\n            (factory((global['ngx-permissions'] = global['ngx-permissions'] || {}), global._angular_core, global.rxjs, global.rxjs_operators, global._angular_router));\n}(this, (function (exports, _angular_core, rxjs, rxjs_operators, _angular_router) {\n    'use strict';\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var NgxPermissionsPredefinedStrategies = {\n        REMOVE: 'remove',\n        SHOW: 'show'\n    };\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var NgxPermissionsConfigurationStore = /** @class */ /*@__PURE__*/ (function () {\n        function NgxPermissionsConfigurationStore() {\n            this.strategiesSource = new rxjs.BehaviorSubject({});\n            this.strategies$ = this.strategiesSource.asObservable();\n        }\n        NgxPermissionsConfigurationStore.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        NgxPermissionsConfigurationStore.ctorParameters = function () { return []; };\n        return NgxPermissionsConfigurationStore;\n    }());\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var USE_CONFIGURATION_STORE = new _angular_core.InjectionToken('USE_CONFIGURATION_STORE');\n    var NgxPermissionsConfigurationService = /** @class */ /*@__PURE__*/ (function () {\n        function NgxPermissionsConfigurationService(isolate, configurationStore) {\n            if (isolate === void 0) {\n                isolate = false;\n            }\n            this.isolate = isolate;\n            this.configurationStore = configurationStore;\n            this.strategiesSource = this.isolate ? new rxjs.BehaviorSubject({}) : this.configurationStore.strategiesSource;\n            this.strategies$ = this.strategiesSource.asObservable();\n            this.onAuthorisedDefaultStrategy = this.isolate ? undefined : this.configurationStore.onAuthorisedDefaultStrategy;\n            this.onUnAuthorisedDefaultStrategy = this.isolate ? undefined : this.configurationStore.onUnAuthorisedDefaultStrategy;\n        }\n        /**\n         * @param {?} name\n         * @return {?}\n         */\n        NgxPermissionsConfigurationService.prototype.setDefaultOnAuthorizedStrategy = /**\n         * @param {?} name\n         * @return {?}\n         */\n            function (name) {\n                if (this.isolate) {\n                    this.onAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n                }\n                else {\n                    this.configurationStore.onAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n                    this.onAuthorisedDefaultStrategy = this.configurationStore.onAuthorisedDefaultStrategy;\n                }\n            };\n        /**\n         * @param {?} name\n         * @return {?}\n         */\n        NgxPermissionsConfigurationService.prototype.setDefaultOnUnauthorizedStrategy = /**\n         * @param {?} name\n         * @return {?}\n         */\n            function (name) {\n                if (this.isolate) {\n                    this.onUnAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n                }\n                else {\n                    this.configurationStore.onUnAuthorisedDefaultStrategy = this.getDefinedStrategy(name);\n                    this.onUnAuthorisedDefaultStrategy = this.configurationStore.onUnAuthorisedDefaultStrategy;\n                }\n            };\n        /**\n         * @param {?} key\n         * @param {?} func\n         * @return {?}\n         */\n        NgxPermissionsConfigurationService.prototype.addPermissionStrategy = /**\n         * @param {?} key\n         * @param {?} func\n         * @return {?}\n         */\n            function (key, func) {\n                this.strategiesSource.value[key] = func;\n            };\n        /**\n         * @param {?} key\n         * @return {?}\n         */\n        NgxPermissionsConfigurationService.prototype.getStrategy = /**\n         * @param {?} key\n         * @return {?}\n         */\n            function (key) {\n                return this.strategiesSource.value[key];\n            };\n        /**\n         * @return {?}\n         */\n        NgxPermissionsConfigurationService.prototype.getAllStrategies = /**\n         * @return {?}\n         */\n            function () {\n                return this.strategiesSource.value;\n            };\n        /**\n         * @param {?} name\n         * @return {?}\n         */\n        NgxPermissionsConfigurationService.prototype.getDefinedStrategy = /**\n         * @param {?} name\n         * @return {?}\n         */\n            function (name) {\n                if (this.strategiesSource.value[name] || this.isPredefinedStrategy(name)) {\n                    return name;\n                }\n                else {\n                    throw new Error(\"No ' \" + name + \" ' strategy is found please define one\");\n                }\n            };\n        /**\n         * @param {?} strategy\n         * @return {?}\n         */\n        NgxPermissionsConfigurationService.prototype.isPredefinedStrategy = /**\n         * @param {?} strategy\n         * @return {?}\n         */\n            function (strategy) {\n                return strategy === NgxPermissionsPredefinedStrategies.SHOW || strategy === NgxPermissionsPredefinedStrategies.REMOVE;\n            };\n        NgxPermissionsConfigurationService.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        NgxPermissionsConfigurationService.ctorParameters = function () {\n            return [\n                { type: undefined, decorators: [{ type: _angular_core.Inject, args: [USE_CONFIGURATION_STORE,] },] },\n                { type: NgxPermissionsConfigurationStore, },\n            ];\n        };\n        return NgxPermissionsConfigurationService;\n    }());\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var NgxPermissionsStore = /** @class */ /*@__PURE__*/ (function () {\n        function NgxPermissionsStore() {\n            this.permissionsSource = new rxjs.BehaviorSubject({});\n            this.permissions$ = this.permissionsSource.asObservable();\n        }\n        NgxPermissionsStore.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        NgxPermissionsStore.ctorParameters = function () { return []; };\n        return NgxPermissionsStore;\n    }());\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    /**\n     * @param {?} functionToCheck\n     * @return {?}\n     */\n    function isFunction(functionToCheck) {\n        var /** @type {?} */ getType = {};\n        return !!functionToCheck && functionToCheck instanceof Function && getType.toString.call(functionToCheck) === '[object Function]';\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    function isPlainObject(value) {\n        if (Object.prototype.toString.call(value) !== '[object Object]') {\n            return false;\n        }\n        else {\n            var /** @type {?} */ prototype = Object.getPrototypeOf(value);\n            return prototype === null || prototype === Object.prototype;\n        }\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    function isString(value) {\n        return !!value && typeof value === 'string';\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    function isBoolean(value) {\n        return typeof value === 'boolean';\n    }\n    /**\n     * @param {?} promise\n     * @return {?}\n     */\n    function isPromise(promise) {\n        return Object.prototype.toString.call(promise) === '[object Promise]';\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    function notEmptyValue(value) {\n        if (Array.isArray(value)) {\n            return value.length > 0;\n        }\n        return !!value;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    function transformStringToArray(value) {\n        if (isString(value)) {\n            return [value];\n        }\n        return value;\n    }\n    var __assign = (undefined && undefined.__assign) || Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s)\n                if (Object.prototype.hasOwnProperty.call(s, p))\n                    t[p] = s[p];\n        }\n        return t;\n    };\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var USE_PERMISSIONS_STORE = new _angular_core.InjectionToken('USE_PERMISSIONS_STORE');\n    var NgxPermissionsService = /** @class */ /*@__PURE__*/ (function () {\n        function NgxPermissionsService(isolate, permissionsStore) {\n            if (isolate === void 0) {\n                isolate = false;\n            }\n            this.isolate = isolate;\n            this.permissionsStore = permissionsStore;\n            this.permissionsSource = isolate ? new rxjs.BehaviorSubject({}) : permissionsStore.permissionsSource;\n            this.permissions$ = this.permissionsSource.asObservable();\n        }\n        /**\n         * Remove all permissions from permissions source\n         * @return {?}\n         */\n        NgxPermissionsService.prototype.flushPermissions = /**\n         * Remove all permissions from permissions source\n         * @return {?}\n         */\n            function () {\n                this.permissionsSource.next({});\n            };\n        /**\n         * @param {?} permission\n         * @return {?}\n         */\n        NgxPermissionsService.prototype.hasPermission = /**\n         * @param {?} permission\n         * @return {?}\n         */\n            function (permission) {\n                if (!permission || (Array.isArray(permission) && permission.length === 0)) {\n                    return Promise.resolve(true);\n                }\n                permission = transformStringToArray(permission);\n                return this.hasArrayPermission(permission);\n            };\n        /**\n         * @param {?} permissions\n         * @param {?=} validationFunction\n         * @return {?}\n         */\n        NgxPermissionsService.prototype.loadPermissions = /**\n         * @param {?} permissions\n         * @param {?=} validationFunction\n         * @return {?}\n         */\n            function (permissions, validationFunction) {\n                var _this = this;\n                var /** @type {?} */ newPermissions = permissions.reduce(function (source, p) {\n                    return _this.reducePermission(source, p, validationFunction);\n                }, {});\n                this.permissionsSource.next(newPermissions);\n            };\n        /**\n         * @param {?} permission\n         * @param {?=} validationFunction\n         * @return {?}\n         */\n        NgxPermissionsService.prototype.addPermission = /**\n         * @param {?} permission\n         * @param {?=} validationFunction\n         * @return {?}\n         */\n            function (permission, validationFunction) {\n                var _this = this;\n                if (Array.isArray(permission)) {\n                    var /** @type {?} */ permissions = permission.reduce(function (source, p) {\n                        return _this.reducePermission(source, p, validationFunction);\n                    }, this.permissionsSource.value);\n                    this.permissionsSource.next(permissions);\n                }\n                else {\n                    var /** @type {?} */ permissions = this.reducePermission(this.permissionsSource.value, permission, validationFunction);\n                    this.permissionsSource.next(permissions);\n                }\n            };\n        /**\n         * @param {?} permissionName\n         * @return {?}\n         */\n        NgxPermissionsService.prototype.removePermission = /**\n         * @param {?} permissionName\n         * @return {?}\n         */\n            function (permissionName) {\n                var /** @type {?} */ permissions = __assign({}, this.permissionsSource.value);\n                delete permissions[permissionName];\n                this.permissionsSource.next(permissions);\n            };\n        /**\n         * @param {?} name\n         * @return {?}\n         */\n        NgxPermissionsService.prototype.getPermission = /**\n         * @param {?} name\n         * @return {?}\n         */\n            function (name) {\n                return this.permissionsSource.value[name];\n            };\n        /**\n         * @return {?}\n         */\n        NgxPermissionsService.prototype.getPermissions = /**\n         * @return {?}\n         */\n            function () {\n                return this.permissionsSource.value;\n            };\n        /**\n         * @param {?} source\n         * @param {?} name\n         * @param {?=} validationFunction\n         * @return {?}\n         */\n        NgxPermissionsService.prototype.reducePermission = /**\n         * @param {?} source\n         * @param {?} name\n         * @param {?=} validationFunction\n         * @return {?}\n         */\n            function (source, name, validationFunction) {\n                if (!!validationFunction && isFunction(validationFunction)) {\n                    return __assign({}, source, (_a = {}, _a[name] = { name: name, validationFunction: validationFunction }, _a));\n                }\n                else {\n                    return __assign({}, source, (_b = {}, _b[name] = { name: name }, _b));\n                }\n                var _a, _b;\n            };\n        /**\n         * @param {?} permissions\n         * @return {?}\n         */\n        NgxPermissionsService.prototype.hasArrayPermission = /**\n         * @param {?} permissions\n         * @return {?}\n         */\n            function (permissions) {\n                var _this = this;\n                var /** @type {?} */ promises = permissions.map(function (key) {\n                    if (_this.hasPermissionValidationFunction(key)) {\n                        var /** @type {?} */ immutableValue_1 = __assign({}, _this.permissionsSource.value);\n                        var /** @type {?} */ validationFunction_1 = /** @type {?} */ (_this.permissionsSource.value[key].validationFunction);\n                        return rxjs.of(null).pipe(rxjs_operators.map(function () { return validationFunction_1(key, immutableValue_1); }), rxjs_operators.switchMap(function (promise) {\n                            return isBoolean(promise) ?\n                                rxjs.of(/** @type {?} */ (promise)) : /** @type {?} */ (promise);\n                        }), rxjs_operators.catchError(function () { return rxjs.of(false); }));\n                    }\n                    // check for name of the permission if there is no validation function\n                    return rxjs.of(!!_this.permissionsSource.value[key]);\n                });\n                return rxjs.from(promises).pipe(rxjs_operators.mergeAll(), rxjs_operators.first(function (data) { return data !== false; }, false), rxjs_operators.map(function (data) { return data === false ? false : true; })).toPromise().then(function (data) { return data; });\n            };\n        /**\n         * @param {?} key\n         * @return {?}\n         */\n        NgxPermissionsService.prototype.hasPermissionValidationFunction = /**\n         * @param {?} key\n         * @return {?}\n         */\n            function (key) {\n                return !!this.permissionsSource.value[key] &&\n                    !!this.permissionsSource.value[key].validationFunction &&\n                    isFunction(this.permissionsSource.value[key].validationFunction);\n            };\n        NgxPermissionsService.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        NgxPermissionsService.ctorParameters = function () {\n            return [\n                { type: undefined, decorators: [{ type: _angular_core.Inject, args: [USE_PERMISSIONS_STORE,] },] },\n                { type: NgxPermissionsStore, },\n            ];\n        };\n        return NgxPermissionsService;\n    }());\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var NgxRolesStore = /** @class */ /*@__PURE__*/ (function () {\n        function NgxRolesStore() {\n            this.rolesSource = new rxjs.BehaviorSubject({});\n            this.roles$ = this.rolesSource.asObservable();\n        }\n        return NgxRolesStore;\n    }());\n    var __assign$1 = (undefined && undefined.__assign) || Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s)\n                if (Object.prototype.hasOwnProperty.call(s, p))\n                    t[p] = s[p];\n        }\n        return t;\n    };\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var USE_ROLES_STORE = new _angular_core.InjectionToken('USE_ROLES_STORE');\n    var NgxRolesService = /** @class */ /*@__PURE__*/ (function () {\n        function NgxRolesService(isolate, rolesStore, permissionsService) {\n            if (isolate === void 0) {\n                isolate = false;\n            }\n            this.isolate = isolate;\n            this.rolesStore = rolesStore;\n            this.permissionsService = permissionsService;\n            this.rolesSource = this.isolate ? new rxjs.BehaviorSubject({}) : this.rolesStore.rolesSource;\n            this.roles$ = this.rolesSource.asObservable();\n        }\n        /**\n         * @param {?} name\n         * @param {?} validationFunction\n         * @return {?}\n         */\n        NgxRolesService.prototype.addRole = /**\n         * @param {?} name\n         * @param {?} validationFunction\n         * @return {?}\n         */\n            function (name, validationFunction) {\n                var /** @type {?} */ roles = __assign$1({}, this.rolesSource.value, (_a = {}, _a[name] = { name: name, validationFunction: validationFunction }, _a));\n                this.rolesSource.next(roles);\n                var _a;\n            };\n        /**\n         * @param {?} rolesObj\n         * @return {?}\n         */\n        NgxRolesService.prototype.addRoles = /**\n         * @param {?} rolesObj\n         * @return {?}\n         */\n            function (rolesObj) {\n                var _this = this;\n                Object.keys(rolesObj).forEach(function (key, index) {\n                    _this.addRole(key, rolesObj[key]);\n                });\n            };\n        /**\n         * @return {?}\n         */\n        NgxRolesService.prototype.flushRoles = /**\n         * @return {?}\n         */\n            function () {\n                this.rolesSource.next({});\n            };\n        /**\n         * @param {?} roleName\n         * @return {?}\n         */\n        NgxRolesService.prototype.removeRole = /**\n         * @param {?} roleName\n         * @return {?}\n         */\n            function (roleName) {\n                var /** @type {?} */ roles = __assign$1({}, this.rolesSource.value);\n                delete roles[roleName];\n                this.rolesSource.next(roles);\n            };\n        /**\n         * @return {?}\n         */\n        NgxRolesService.prototype.getRoles = /**\n         * @return {?}\n         */\n            function () {\n                return this.rolesSource.value;\n            };\n        /**\n         * @param {?} name\n         * @return {?}\n         */\n        NgxRolesService.prototype.getRole = /**\n         * @param {?} name\n         * @return {?}\n         */\n            function (name) {\n                return this.rolesSource.value[name];\n            };\n        /**\n         * @param {?} names\n         * @return {?}\n         */\n        NgxRolesService.prototype.hasOnlyRoles = /**\n         * @param {?} names\n         * @return {?}\n         */\n            function (names) {\n                var /** @type {?} */ isNamesEmpty = !names || (Array.isArray(names) && names.length === 0);\n                if (isNamesEmpty)\n                    return Promise.resolve(true);\n                names = transformStringToArray(names);\n                return Promise.all([this.hasRoleKey(names), this.hasRolePermission(this.rolesSource.value, names)])\n                    .then(function (_a) {\n                    var hasRoles = _a[0], hasPermissions = _a[1];\n                    return hasRoles || hasPermissions;\n                });\n            };\n        /**\n         * @param {?} roleName\n         * @return {?}\n         */\n        NgxRolesService.prototype.hasRoleKey = /**\n         * @param {?} roleName\n         * @return {?}\n         */\n            function (roleName) {\n                var _this = this;\n                var /** @type {?} */ promises = roleName.map(function (key) {\n                    var /** @type {?} */ hasValidationFunction = !!_this.rolesSource.value[key] &&\n                        !!_this.rolesSource.value[key].validationFunction &&\n                        isFunction(_this.rolesSource.value[key].validationFunction);\n                    if (hasValidationFunction && !isPromise(_this.rolesSource.value[key].validationFunction)) {\n                        var /** @type {?} */ validationFunction_1 = /** @type {?} */ (_this.rolesSource.value[key].validationFunction);\n                        return rxjs.of(null).pipe(rxjs_operators.map(function () { return validationFunction_1(); }), rxjs_operators.switchMap(function (promise) {\n                            return isBoolean(promise) ?\n                                rxjs.of(/** @type {?} */ (promise)) : /** @type {?} */ (promise);\n                        }), rxjs_operators.catchError(function () { return rxjs.of(false); }));\n                    }\n                    return rxjs.of(false);\n                });\n                return rxjs.from(promises).pipe(rxjs_operators.mergeAll(), rxjs_operators.first(function (data) { return data !== false; }, false), rxjs_operators.map(function (data) { return data !== false; })).toPromise().then(function (data) { return data; });\n            };\n        /**\n         * @param {?} roles\n         * @param {?} roleNames\n         * @return {?}\n         */\n        NgxRolesService.prototype.hasRolePermission = /**\n         * @param {?} roles\n         * @param {?} roleNames\n         * @return {?}\n         */\n            function (roles, roleNames) {\n                var _this = this;\n                return rxjs.from(roleNames).pipe(rxjs_operators.mergeMap(function (key) {\n                    if (roles[key] && Array.isArray(roles[key].validationFunction)) {\n                        return rxjs.from(/** @type {?} */ (roles[key].validationFunction)).pipe(rxjs_operators.mergeMap(function (permission) { return _this.permissionsService.hasPermission(permission); }), rxjs_operators.every(function (hasPermissions) { return hasPermissions === true; }));\n                    }\n                    return rxjs.of(false);\n                }), rxjs_operators.first(function (hasPermission) { return hasPermission === true; }, false)).toPromise();\n            };\n        NgxRolesService.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        NgxRolesService.ctorParameters = function () {\n            return [\n                { type: undefined, decorators: [{ type: _angular_core.Inject, args: [USE_ROLES_STORE,] },] },\n                { type: NgxRolesStore, },\n                { type: NgxPermissionsService, },\n            ];\n        };\n        return NgxRolesService;\n    }());\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var NgxPermissionsDirective = /** @class */ /*@__PURE__*/ (function () {\n        function NgxPermissionsDirective(permissionsService, configurationService, rolesService, viewContainer, changeDetector, templateRef) {\n            this.permissionsService = permissionsService;\n            this.configurationService = configurationService;\n            this.rolesService = rolesService;\n            this.viewContainer = viewContainer;\n            this.changeDetector = changeDetector;\n            this.templateRef = templateRef;\n            this.permissionsAuthorized = new _angular_core.EventEmitter();\n            this.permissionsUnauthorized = new _angular_core.EventEmitter();\n            this.firstMergeUnusedRun = 1;\n        }\n        /**\n         * @return {?}\n         */\n        NgxPermissionsDirective.prototype.ngOnInit = /**\n         * @return {?}\n         */\n            function () {\n                this.viewContainer.clear();\n                this.initPermissionSubscription = this.validateExceptOnlyPermissions();\n            };\n        /**\n         * @param {?} changes\n         * @return {?}\n         */\n        NgxPermissionsDirective.prototype.ngOnChanges = /**\n         * @param {?} changes\n         * @return {?}\n         */\n            function (changes) {\n                var _this = this;\n                var /** @type {?} */ onlyChanges = changes['ngxPermissionsOnly'];\n                var /** @type {?} */ exceptChanges = changes['ngxPermissionsExcept'];\n                if (onlyChanges || exceptChanges) {\n                    // Due to bug when you pass empty array\n                    if (onlyChanges && onlyChanges.firstChange)\n                        return;\n                    if (exceptChanges && exceptChanges.firstChange)\n                        return;\n                    rxjs.merge(this.permissionsService.permissions$, this.rolesService.roles$)\n                        .pipe(rxjs_operators.skip(this.firstMergeUnusedRun), rxjs_operators.take(1))\n                        .subscribe(function () {\n                        if (notEmptyValue(_this.ngxPermissionsExcept)) {\n                            _this.validateExceptAndOnlyPermissions();\n                            return;\n                        }\n                        if (notEmptyValue(_this.ngxPermissionsOnly)) {\n                            _this.validateOnlyPermissions();\n                            return;\n                        }\n                        _this.handleAuthorisedPermission(_this.getAuthorisedTemplates());\n                    });\n                }\n            };\n        /**\n         * @return {?}\n         */\n        NgxPermissionsDirective.prototype.ngOnDestroy = /**\n         * @return {?}\n         */\n            function () {\n                if (this.initPermissionSubscription) {\n                    this.initPermissionSubscription.unsubscribe();\n                }\n            };\n        /**\n         * @return {?}\n         */\n        NgxPermissionsDirective.prototype.validateExceptOnlyPermissions = /**\n         * @return {?}\n         */\n            function () {\n                var _this = this;\n                return rxjs.merge(this.permissionsService.permissions$, this.rolesService.roles$)\n                    .pipe(rxjs_operators.skip(this.firstMergeUnusedRun))\n                    .subscribe(function () {\n                    if (notEmptyValue(_this.ngxPermissionsExcept)) {\n                        _this.validateExceptAndOnlyPermissions();\n                        return;\n                    }\n                    if (notEmptyValue(_this.ngxPermissionsOnly)) {\n                        _this.validateOnlyPermissions();\n                        return;\n                    }\n                    _this.handleAuthorisedPermission(_this.getAuthorisedTemplates());\n                });\n            };\n        /**\n         * @return {?}\n         */\n        NgxPermissionsDirective.prototype.validateExceptAndOnlyPermissions = /**\n         * @return {?}\n         */\n            function () {\n                var _this = this;\n                Promise.all([this.permissionsService.hasPermission(this.ngxPermissionsExcept), this.rolesService.hasOnlyRoles(this.ngxPermissionsExcept)])\n                    .then(function (_a) {\n                    var hasPermission = _a[0], hasRole = _a[1];\n                    if (hasPermission || hasRole) {\n                        _this.handleUnauthorisedPermission(_this.ngxPermissionsExceptElse || _this.ngxPermissionsElse);\n                        return;\n                    }\n                    if (!!_this.ngxPermissionsOnly)\n                        throw false;\n                    _this.handleAuthorisedPermission(_this.ngxPermissionsExceptThen || _this.ngxPermissionsThen || _this.templateRef);\n                }).catch(function () {\n                    if (!!_this.ngxPermissionsOnly) {\n                        _this.validateOnlyPermissions();\n                    }\n                    else {\n                        _this.handleAuthorisedPermission(_this.ngxPermissionsExceptThen || _this.ngxPermissionsThen || _this.templateRef);\n                    }\n                });\n            };\n        /**\n         * @return {?}\n         */\n        NgxPermissionsDirective.prototype.validateOnlyPermissions = /**\n         * @return {?}\n         */\n            function () {\n                var _this = this;\n                Promise.all([this.permissionsService.hasPermission(this.ngxPermissionsOnly), this.rolesService.hasOnlyRoles(this.ngxPermissionsOnly)])\n                    .then(function (_a) {\n                    var hasPermissions = _a[0], hasRoles = _a[1];\n                    if (hasPermissions || hasRoles) {\n                        _this.handleAuthorisedPermission(_this.ngxPermissionsOnlyThen || _this.ngxPermissionsThen || _this.templateRef);\n                    }\n                    else {\n                        _this.handleUnauthorisedPermission(_this.ngxPermissionsOnlyElse || _this.ngxPermissionsElse);\n                    }\n                }).catch(function () {\n                    _this.handleUnauthorisedPermission(_this.ngxPermissionsOnlyElse || _this.ngxPermissionsElse);\n                });\n            };\n        /**\n         * @param {?} template\n         * @return {?}\n         */\n        NgxPermissionsDirective.prototype.handleUnauthorisedPermission = /**\n         * @param {?} template\n         * @return {?}\n         */\n            function (template) {\n                if (isBoolean(this.currentAuthorizedState) && !this.currentAuthorizedState)\n                    return;\n                this.currentAuthorizedState = false;\n                this.permissionsUnauthorized.emit();\n                if (this.getUnAuthorizedStrategyInput()) {\n                    this.applyStrategyAccordingToStrategyType(this.getUnAuthorizedStrategyInput());\n                    return;\n                }\n                if (this.configurationService.onUnAuthorisedDefaultStrategy && !this.elseBlockDefined()) {\n                    this.applyStrategy(this.configurationService.onUnAuthorisedDefaultStrategy);\n                }\n                else {\n                    this.showTemplateBlockInView(template);\n                }\n            };\n        /**\n         * @param {?} template\n         * @return {?}\n         */\n        NgxPermissionsDirective.prototype.handleAuthorisedPermission = /**\n         * @param {?} template\n         * @return {?}\n         */\n            function (template) {\n                if (isBoolean(this.currentAuthorizedState) && this.currentAuthorizedState)\n                    return;\n                this.currentAuthorizedState = true;\n                this.permissionsAuthorized.emit();\n                if (this.getAuthorizedStrategyInput()) {\n                    this.applyStrategyAccordingToStrategyType(this.getAuthorizedStrategyInput());\n                    return;\n                }\n                if (this.configurationService.onAuthorisedDefaultStrategy && !this.thenBlockDefined()) {\n                    this.applyStrategy(this.configurationService.onAuthorisedDefaultStrategy);\n                }\n                else {\n                    this.showTemplateBlockInView(template);\n                }\n            };\n        /**\n         * @param {?} strategy\n         * @return {?}\n         */\n        NgxPermissionsDirective.prototype.applyStrategyAccordingToStrategyType = /**\n         * @param {?} strategy\n         * @return {?}\n         */\n            function (strategy) {\n                if (isString(strategy)) {\n                    this.applyStrategy(strategy);\n                    return;\n                }\n                if (isFunction(strategy)) {\n                    this.showTemplateBlockInView(this.templateRef);\n                    ( /** @type {?} */(strategy))(this.templateRef);\n                    return;\n                }\n            };\n        /**\n         * @param {?} template\n         * @return {?}\n         */\n        NgxPermissionsDirective.prototype.showTemplateBlockInView = /**\n         * @param {?} template\n         * @return {?}\n         */\n            function (template) {\n                this.viewContainer.clear();\n                if (!template) {\n                    return;\n                }\n                this.viewContainer.createEmbeddedView(template);\n                this.changeDetector.markForCheck();\n            };\n        /**\n         * @return {?}\n         */\n        NgxPermissionsDirective.prototype.getAuthorisedTemplates = /**\n         * @return {?}\n         */\n            function () {\n                return this.ngxPermissionsOnlyThen\n                    || this.ngxPermissionsExceptThen\n                    || this.ngxPermissionsThen\n                    || this.templateRef;\n            };\n        /**\n         * @return {?}\n         */\n        NgxPermissionsDirective.prototype.elseBlockDefined = /**\n         * @return {?}\n         */\n            function () {\n                return !!this.ngxPermissionsExceptElse || !!this.ngxPermissionsElse;\n            };\n        /**\n         * @return {?}\n         */\n        NgxPermissionsDirective.prototype.thenBlockDefined = /**\n         * @return {?}\n         */\n            function () {\n                return !!this.ngxPermissionsExceptThen || !!this.ngxPermissionsThen;\n            };\n        /**\n         * @return {?}\n         */\n        NgxPermissionsDirective.prototype.getAuthorizedStrategyInput = /**\n         * @return {?}\n         */\n            function () {\n                return this.ngxPermissionsOnlyAuthorisedStrategy ||\n                    this.ngxPermissionsExceptAuthorisedStrategy ||\n                    this.ngxPermissionsAuthorisedStrategy;\n            };\n        /**\n         * @return {?}\n         */\n        NgxPermissionsDirective.prototype.getUnAuthorizedStrategyInput = /**\n         * @return {?}\n         */\n            function () {\n                return this.ngxPermissionsOnlyUnauthorisedStrategy ||\n                    this.ngxPermissionsExceptUnauthorisedStrategy ||\n                    this.ngxPermissionsUnauthorisedStrategy;\n            };\n        /**\n         * @param {?} str\n         * @return {?}\n         */\n        NgxPermissionsDirective.prototype.applyStrategy = /**\n         * @param {?} str\n         * @return {?}\n         */\n            function (str) {\n                if (str === NgxPermissionsPredefinedStrategies.SHOW) {\n                    this.showTemplateBlockInView(this.templateRef);\n                    return;\n                }\n                if (str === NgxPermissionsPredefinedStrategies.REMOVE) {\n                    this.viewContainer.clear();\n                    return;\n                }\n                var /** @type {?} */ strategy = this.configurationService.getStrategy(str);\n                this.showTemplateBlockInView(this.templateRef);\n                strategy(this.templateRef);\n            };\n        NgxPermissionsDirective.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]'\n                    },] },\n        ];\n        /** @nocollapse */\n        NgxPermissionsDirective.ctorParameters = function () {\n            return [\n                { type: NgxPermissionsService, },\n                { type: NgxPermissionsConfigurationService, },\n                { type: NgxRolesService, },\n                { type: _angular_core.ViewContainerRef, },\n                { type: _angular_core.ChangeDetectorRef, },\n                { type: _angular_core.TemplateRef, },\n            ];\n        };\n        NgxPermissionsDirective.propDecorators = {\n            \"ngxPermissionsOnly\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsOnlyThen\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsOnlyElse\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsExcept\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsExceptElse\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsExceptThen\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsThen\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsElse\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsOnlyAuthorisedStrategy\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsOnlyUnauthorisedStrategy\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsExceptUnauthorisedStrategy\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsExceptAuthorisedStrategy\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsUnauthorisedStrategy\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsAuthorisedStrategy\": [{ type: _angular_core.Input },],\n            \"permissionsAuthorized\": [{ type: _angular_core.Output },],\n            \"permissionsUnauthorized\": [{ type: _angular_core.Output },],\n        };\n        return NgxPermissionsDirective;\n    }());\n    var __assign$2 = (undefined && undefined.__assign) || Object.assign || function (t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s)\n                if (Object.prototype.hasOwnProperty.call(s, p))\n                    t[p] = s[p];\n        }\n        return t;\n    };\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var NgxPermissionsGuard = /** @class */ /*@__PURE__*/ (function () {\n        function NgxPermissionsGuard(permissionsService, rolesService, router) {\n            this.permissionsService = permissionsService;\n            this.rolesService = rolesService;\n            this.router = router;\n        }\n        /**\n         * @param {?} route\n         * @param {?} state\n         * @return {?}\n         */\n        NgxPermissionsGuard.prototype.canActivate = /**\n         * @param {?} route\n         * @param {?} state\n         * @return {?}\n         */\n            function (route, state) {\n                return this.hasPermissions(route, state);\n            };\n        /**\n         * @param {?} childRoute\n         * @param {?} state\n         * @return {?}\n         */\n        NgxPermissionsGuard.prototype.canActivateChild = /**\n         * @param {?} childRoute\n         * @param {?} state\n         * @return {?}\n         */\n            function (childRoute, state) {\n                return this.hasPermissions(childRoute, state);\n            };\n        /**\n         * @param {?} route\n         * @return {?}\n         */\n        NgxPermissionsGuard.prototype.canLoad = /**\n         * @param {?} route\n         * @return {?}\n         */\n            function (route) {\n                return this.hasPermissions(route);\n            };\n        /**\n         * @param {?} route\n         * @param {?=} state\n         * @return {?}\n         */\n        NgxPermissionsGuard.prototype.hasPermissions = /**\n         * @param {?} route\n         * @param {?=} state\n         * @return {?}\n         */\n            function (route, state) {\n                var /** @type {?} */ purePermissions = !!route && route.data ? /** @type {?} */ (route.data['permissions']) : {};\n                var /** @type {?} */ permissions = this.transformPermission(purePermissions, route, state);\n                if (this.isParameterAvailable(permissions.except)) {\n                    return this.passingExceptPermissionsValidation(permissions, route, state);\n                }\n                if (this.isParameterAvailable(permissions.only)) {\n                    return this.passingOnlyPermissionsValidation(permissions, route, state);\n                }\n                return true;\n            };\n        /**\n         * @param {?} purePermissions\n         * @param {?} route\n         * @param {?} state\n         * @return {?}\n         */\n        NgxPermissionsGuard.prototype.transformPermission = /**\n         * @param {?} purePermissions\n         * @param {?} route\n         * @param {?} state\n         * @return {?}\n         */\n            function (purePermissions, route, state) {\n                var /** @type {?} */ permissions = __assign$2({}, purePermissions);\n                if (isFunction(permissions.except)) {\n                    permissions.except = ( /** @type {?} */(permissions.except))(route, state);\n                }\n                if (isFunction(permissions.only)) {\n                    permissions.only = ( /** @type {?} */(permissions.only))(route, state);\n                }\n                permissions.except = transformStringToArray(permissions.except);\n                permissions.only = transformStringToArray(permissions.only);\n                return permissions;\n            };\n        /**\n         * @param {?} permission\n         * @return {?}\n         */\n        NgxPermissionsGuard.prototype.isParameterAvailable = /**\n         * @param {?} permission\n         * @return {?}\n         */\n            function (permission) {\n                return !!(permission) && permission.length > 0;\n            };\n        /**\n         * @param {?} permissions\n         * @param {?} route\n         * @param {?} state\n         * @return {?}\n         */\n        NgxPermissionsGuard.prototype.passingExceptPermissionsValidation = /**\n         * @param {?} permissions\n         * @param {?} route\n         * @param {?} state\n         * @return {?}\n         */\n            function (permissions, route, state) {\n                var _this = this;\n                if (!!permissions.redirectTo && ((isFunction(permissions.redirectTo)) || (isPlainObject(permissions.redirectTo) && !this.isRedirectionWithParameters(permissions.redirectTo)))) {\n                    var /** @type {?} */ failedPermission_1 = '';\n                    return rxjs.from(/** @type {?} */ (permissions.except)).pipe(rxjs_operators.mergeMap(function (data) {\n                        return rxjs.forkJoin([\n                            _this.permissionsService.hasPermission(/** @type {?} */ (data)),\n                            _this.rolesService.hasOnlyRoles(/** @type {?} */ (data))\n                        ]).pipe(rxjs_operators.tap(function (hasPermissions) {\n                            var /** @type {?} */ dontHavePermissions = hasPermissions.every(function (data) { return data === false; });\n                            if (!dontHavePermissions) {\n                                failedPermission_1 = data;\n                            }\n                        }));\n                    }), rxjs_operators.first(function (data) { return data.some(function (data) { return data === true; }); }, false), rxjs_operators.mergeMap(function (isAllFalse) {\n                        if (!!failedPermission_1) {\n                            _this.handleRedirectOfFailedPermission(permissions, failedPermission_1, route, state);\n                            return rxjs.of(false);\n                        }\n                        if (!isAllFalse && permissions.only) {\n                            return _this.onlyRedirectCheck(permissions, route, state);\n                        }\n                        return rxjs.of(!isAllFalse);\n                    })).toPromise();\n                }\n                return Promise.all([this.permissionsService.hasPermission(/** @type {?} */ (permissions.except)), this.rolesService.hasOnlyRoles(/** @type {?} */ (permissions.except))])\n                    .then(function (_a) {\n                    var hasPermission = _a[0], hasRoles = _a[1];\n                    if (hasPermission || hasRoles) {\n                        if (permissions.redirectTo) {\n                            _this.redirectToAnotherRoute(permissions.redirectTo, route, state);\n                        }\n                        return false;\n                    }\n                    if (permissions.only) {\n                        return _this.checkOnlyPermissions(permissions, route, state);\n                    }\n                    return true;\n                });\n            };\n        /**\n         * @param {?} redirectTo\n         * @param {?} route\n         * @param {?=} state\n         * @param {?=} failedPermissionName\n         * @return {?}\n         */\n        NgxPermissionsGuard.prototype.redirectToAnotherRoute = /**\n         * @param {?} redirectTo\n         * @param {?} route\n         * @param {?=} state\n         * @param {?=} failedPermissionName\n         * @return {?}\n         */\n            function (redirectTo, route, state, failedPermissionName) {\n                if (isFunction(redirectTo)) {\n                    redirectTo = ( /** @type {?} */(redirectTo))(failedPermissionName, route, state);\n                }\n                if (this.isRedirectionWithParameters(redirectTo)) {\n                    if (this.hasNavigationExtrasAsFunction(redirectTo)) {\n                        ( /** @type {?} */(redirectTo)).navigationExtras = ( /** @type {?} */(( /** @type {?} */(redirectTo)).navigationExtras))(route, state);\n                    }\n                    if (this.hasNavigationCommandsAsFunction(redirectTo)) {\n                        ( /** @type {?} */(redirectTo)).navigationCommands = ( /** @type {?} */(( /** @type {?} */(redirectTo)).navigationCommands))(route, state);\n                    }\n                    this.router.navigate(( /** @type {?} */(( /** @type {?} */(redirectTo)).navigationCommands)), ( /** @type {?} */(( /** @type {?} */(redirectTo)).navigationExtras)));\n                    return;\n                }\n                if (Array.isArray(redirectTo)) {\n                    this.router.navigate(redirectTo);\n                }\n                else {\n                    this.router.navigate([redirectTo]);\n                }\n            };\n        /**\n         * @param {?} object\n         * @return {?}\n         */\n        NgxPermissionsGuard.prototype.isRedirectionWithParameters = /**\n         * @param {?} object\n         * @return {?}\n         */\n            function (object) {\n                return isPlainObject(object) && (!!object.navigationCommands || !!object.navigationExtras);\n            };\n        /**\n         * @param {?} redirectTo\n         * @return {?}\n         */\n        NgxPermissionsGuard.prototype.hasNavigationExtrasAsFunction = /**\n         * @param {?} redirectTo\n         * @return {?}\n         */\n            function (redirectTo) {\n                return !!( /** @type {?} */(redirectTo)).navigationExtras &&\n                    isFunction(( /** @type {?} */(redirectTo)).navigationExtras);\n            };\n        /**\n         * @param {?} redirectTo\n         * @return {?}\n         */\n        NgxPermissionsGuard.prototype.hasNavigationCommandsAsFunction = /**\n         * @param {?} redirectTo\n         * @return {?}\n         */\n            function (redirectTo) {\n                return !!( /** @type {?} */(redirectTo)).navigationCommands &&\n                    isFunction(( /** @type {?} */(redirectTo)).navigationCommands);\n            };\n        /**\n         * @param {?} permissions\n         * @param {?} route\n         * @param {?=} state\n         * @return {?}\n         */\n        NgxPermissionsGuard.prototype.onlyRedirectCheck = /**\n         * @param {?} permissions\n         * @param {?} route\n         * @param {?=} state\n         * @return {?}\n         */\n            function (permissions, route, state) {\n                var _this = this;\n                var /** @type {?} */ failedPermission = '';\n                return rxjs.from(permissions.only).pipe(rxjs_operators.mergeMap(function (data) {\n                    return rxjs.forkJoin([\n                        _this.permissionsService.hasPermission(/** @type {?} */ (data)),\n                        _this.rolesService.hasOnlyRoles(/** @type {?} */ (data))\n                    ]).pipe(rxjs_operators.tap(function (hasPermission) {\n                        var /** @type {?} */ failed = hasPermission.every(function (data) { return data === false; });\n                        if (failed) {\n                            failedPermission = data;\n                        }\n                    }));\n                }), rxjs_operators.first(function (data) {\n                    if (isFunction(permissions.redirectTo)) {\n                        return data.some(function (data) { return data === true; });\n                    }\n                    return data.every(function (data) { return data === false; });\n                }, false), rxjs_operators.mergeMap(function (pass) {\n                    if (isFunction(permissions.redirectTo)) {\n                        if (pass) {\n                            return rxjs.of(true);\n                        }\n                        else {\n                            _this.handleRedirectOfFailedPermission(permissions, failedPermission, route, state);\n                            return rxjs.of(false);\n                        }\n                    }\n                    else {\n                        if (!!failedPermission) {\n                            _this.handleRedirectOfFailedPermission(permissions, failedPermission, route, state);\n                        }\n                        return rxjs.of(!pass);\n                    }\n                })).toPromise();\n            };\n        /**\n         * @param {?} permissions\n         * @param {?} failedPermission\n         * @param {?} route\n         * @param {?=} state\n         * @return {?}\n         */\n        NgxPermissionsGuard.prototype.handleRedirectOfFailedPermission = /**\n         * @param {?} permissions\n         * @param {?} failedPermission\n         * @param {?} route\n         * @param {?=} state\n         * @return {?}\n         */\n            function (permissions, failedPermission, route, state) {\n                if (this.isFailedPermissionPropertyOfRedirectTo(permissions, failedPermission)) {\n                    this.redirectToAnotherRoute(( /** @type {?} */(permissions.redirectTo))[failedPermission], route, state, failedPermission);\n                }\n                else {\n                    if (isFunction(permissions.redirectTo)) {\n                        this.redirectToAnotherRoute(( /** @type {?} */(permissions.redirectTo)), route, state, failedPermission);\n                    }\n                    else {\n                        this.redirectToAnotherRoute(( /** @type {?} */(permissions.redirectTo))['default'], route, state, failedPermission);\n                    }\n                }\n            };\n        /**\n         * @param {?} permissions\n         * @param {?} failedPermission\n         * @return {?}\n         */\n        NgxPermissionsGuard.prototype.isFailedPermissionPropertyOfRedirectTo = /**\n         * @param {?} permissions\n         * @param {?} failedPermission\n         * @return {?}\n         */\n            function (permissions, failedPermission) {\n                return !!permissions.redirectTo && permissions.redirectTo[ /** @type {?} */(failedPermission)];\n            };\n        /**\n         * @param {?} purePermissions\n         * @param {?} route\n         * @param {?=} state\n         * @return {?}\n         */\n        NgxPermissionsGuard.prototype.checkOnlyPermissions = /**\n         * @param {?} purePermissions\n         * @param {?} route\n         * @param {?=} state\n         * @return {?}\n         */\n            function (purePermissions, route, state) {\n                var _this = this;\n                var /** @type {?} */ permissions = __assign$2({}, purePermissions);\n                return Promise.all([this.permissionsService.hasPermission(/** @type {?} */ (permissions.only)), this.rolesService.hasOnlyRoles(/** @type {?} */ (permissions.only))])\n                    .then(function (_a) {\n                    var hasPermission = _a[0], hasRole = _a[1];\n                    if (hasPermission || hasRole)\n                        return true;\n                    if (permissions.redirectTo) {\n                        _this.redirectToAnotherRoute(permissions.redirectTo, route, state);\n                    }\n                    return false;\n                });\n            };\n        /**\n         * @param {?} permissions\n         * @param {?} route\n         * @param {?=} state\n         * @return {?}\n         */\n        NgxPermissionsGuard.prototype.passingOnlyPermissionsValidation = /**\n         * @param {?} permissions\n         * @param {?} route\n         * @param {?=} state\n         * @return {?}\n         */\n            function (permissions, route, state) {\n                if ((isFunction(permissions.redirectTo) || isPlainObject(permissions.redirectTo) && !this.isRedirectionWithParameters(permissions.redirectTo))) {\n                    return this.onlyRedirectCheck(permissions, route, state);\n                }\n                return this.checkOnlyPermissions(permissions, route, state);\n            };\n        NgxPermissionsGuard.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        NgxPermissionsGuard.ctorParameters = function () {\n            return [\n                { type: NgxPermissionsService, },\n                { type: NgxRolesService, },\n                { type: _angular_router.Router, },\n            ];\n        };\n        return NgxPermissionsGuard;\n    }());\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var NgxPermissionsAllowStubDirective = /** @class */ /*@__PURE__*/ (function () {\n        function NgxPermissionsAllowStubDirective(viewContainer, templateRef) {\n            this.viewContainer = viewContainer;\n            this.templateRef = templateRef;\n            this.permissionsAuthorized = new _angular_core.EventEmitter();\n            this.permissionsUnauthorized = new _angular_core.EventEmitter();\n        }\n        /**\n         * @return {?}\n         */\n        NgxPermissionsAllowStubDirective.prototype.ngOnInit = /**\n         * @return {?}\n         */\n            function () {\n                this.viewContainer.clear();\n                this.viewContainer.createEmbeddedView(this.getAuthorizedTemplate());\n                this.permissionsUnauthorized.emit();\n            };\n        /**\n         * @return {?}\n         */\n        NgxPermissionsAllowStubDirective.prototype.getAuthorizedTemplate = /**\n         * @return {?}\n         */\n            function () {\n                return this.ngxPermissionsOnlyThen ||\n                    this.ngxPermissionsExceptThen ||\n                    this.ngxPermissionsThen ||\n                    this.templateRef;\n            };\n        NgxPermissionsAllowStubDirective.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]'\n                    },] },\n        ];\n        /** @nocollapse */\n        NgxPermissionsAllowStubDirective.ctorParameters = function () {\n            return [\n                { type: _angular_core.ViewContainerRef, },\n                { type: _angular_core.TemplateRef, },\n            ];\n        };\n        NgxPermissionsAllowStubDirective.propDecorators = {\n            \"ngxPermissionsOnly\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsOnlyThen\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsOnlyElse\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsExcept\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsExceptElse\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsExceptThen\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsThen\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsElse\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsOnlyAuthorisedStrategy\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsOnlyUnauthorisedStrategy\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsExceptUnauthorisedStrategy\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsExceptAuthorisedStrategy\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsUnauthorisedStrategy\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsAuthorisedStrategy\": [{ type: _angular_core.Input },],\n            \"permissionsAuthorized\": [{ type: _angular_core.Output },],\n            \"permissionsUnauthorized\": [{ type: _angular_core.Output },],\n        };\n        return NgxPermissionsAllowStubDirective;\n    }());\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var NgxPermissionsRestrictStubDirective = /** @class */ /*@__PURE__*/ (function () {\n        function NgxPermissionsRestrictStubDirective(viewContainer) {\n            this.viewContainer = viewContainer;\n            this.permissionsAuthorized = new _angular_core.EventEmitter();\n            this.permissionsUnauthorized = new _angular_core.EventEmitter();\n        }\n        /**\n         * @return {?}\n         */\n        NgxPermissionsRestrictStubDirective.prototype.ngOnInit = /**\n         * @return {?}\n         */\n            function () {\n                this.viewContainer.clear();\n                if (this.getUnAuthorizedTemplate()) {\n                    this.viewContainer.createEmbeddedView(this.getUnAuthorizedTemplate());\n                }\n                this.permissionsUnauthorized.emit();\n            };\n        /**\n         * @return {?}\n         */\n        NgxPermissionsRestrictStubDirective.prototype.getUnAuthorizedTemplate = /**\n         * @return {?}\n         */\n            function () {\n                return this.ngxPermissionsOnlyElse ||\n                    this.ngxPermissionsExceptElse ||\n                    this.ngxPermissionsElse;\n            };\n        NgxPermissionsRestrictStubDirective.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: '[ngxPermissionsOnly],[ngxPermissionsExcept]'\n                    },] },\n        ];\n        /** @nocollapse */\n        NgxPermissionsRestrictStubDirective.ctorParameters = function () {\n            return [\n                { type: _angular_core.ViewContainerRef, },\n            ];\n        };\n        NgxPermissionsRestrictStubDirective.propDecorators = {\n            \"ngxPermissionsOnly\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsOnlyThen\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsOnlyElse\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsExcept\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsExceptElse\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsExceptThen\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsThen\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsElse\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsOnlyAuthorisedStrategy\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsOnlyUnauthorisedStrategy\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsExceptUnauthorisedStrategy\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsExceptAuthorisedStrategy\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsUnauthorisedStrategy\": [{ type: _angular_core.Input },],\n            \"ngxPermissionsAuthorisedStrategy\": [{ type: _angular_core.Input },],\n            \"permissionsAuthorized\": [{ type: _angular_core.Output },],\n            \"permissionsUnauthorized\": [{ type: _angular_core.Output },],\n        };\n        return NgxPermissionsRestrictStubDirective;\n    }());\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    var NgxRole = /** @class */ /*@__PURE__*/ (function () {\n        function NgxRole(name, validationFunction) {\n            this.name = name;\n            this.validationFunction = validationFunction;\n        }\n        return NgxRole;\n    }());\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes} checked by tsc\n     */\n    /**\n     * @record\n     */\n    function NgxPermissionsModuleConfig() { }\n    var NgxPermissionsModule = /** @class */ /*@__PURE__*/ (function () {\n        function NgxPermissionsModule() {\n        }\n        /**\n         * @param {?=} config\n         * @return {?}\n         */\n        NgxPermissionsModule.forRoot = /**\n         * @param {?=} config\n         * @return {?}\n         */\n            function (config) {\n                if (config === void 0) {\n                    config = {};\n                }\n                return {\n                    ngModule: NgxPermissionsModule,\n                    providers: [\n                        NgxPermissionsStore,\n                        NgxRolesStore,\n                        NgxPermissionsConfigurationStore,\n                        NgxPermissionsService,\n                        NgxPermissionsGuard,\n                        NgxRolesService,\n                        NgxPermissionsConfigurationService,\n                        { provide: USE_PERMISSIONS_STORE, useValue: config.permissionsIsolate },\n                        { provide: USE_ROLES_STORE, useValue: config.rolesIsolate },\n                        { provide: USE_CONFIGURATION_STORE, useValue: config.configurationIsolate },\n                    ]\n                };\n            };\n        /**\n         * @param {?=} config\n         * @return {?}\n         */\n        NgxPermissionsModule.forChild = /**\n         * @param {?=} config\n         * @return {?}\n         */\n            function (config) {\n                if (config === void 0) {\n                    config = {};\n                }\n                return {\n                    ngModule: NgxPermissionsModule,\n                    providers: [\n                        { provide: USE_PERMISSIONS_STORE, useValue: config.permissionsIsolate },\n                        { provide: USE_ROLES_STORE, useValue: config.rolesIsolate },\n                        { provide: USE_CONFIGURATION_STORE, useValue: config.configurationIsolate },\n                        NgxPermissionsConfigurationService,\n                        NgxPermissionsService,\n                        NgxRolesService,\n                        NgxPermissionsGuard\n                    ]\n                };\n            };\n        NgxPermissionsModule.decorators = [\n            { type: _angular_core.NgModule, args: [{\n                        imports: [],\n                        declarations: [\n                            NgxPermissionsDirective\n                        ],\n                        exports: [\n                            NgxPermissionsDirective\n                        ]\n                    },] },\n        ];\n        return NgxPermissionsModule;\n    }());\n    var NgxPermissionsAllowStubModule = /** @class */ /*@__PURE__*/ (function () {\n        function NgxPermissionsAllowStubModule() {\n        }\n        NgxPermissionsAllowStubModule.decorators = [\n            { type: _angular_core.NgModule, args: [{\n                        imports: [],\n                        declarations: [\n                            NgxPermissionsAllowStubDirective\n                        ],\n                        exports: [\n                            NgxPermissionsAllowStubDirective\n                        ]\n                    },] },\n        ];\n        return NgxPermissionsAllowStubModule;\n    }());\n    var NgxPermissionsRestrictStubModule = /** @class */ /*@__PURE__*/ (function () {\n        function NgxPermissionsRestrictStubModule() {\n        }\n        NgxPermissionsRestrictStubModule.decorators = [\n            { type: _angular_core.NgModule, args: [{\n                        imports: [],\n                        declarations: [\n                            NgxPermissionsRestrictStubDirective\n                        ],\n                        exports: [\n                            NgxPermissionsRestrictStubDirective\n                        ]\n                    },] },\n        ];\n        return NgxPermissionsRestrictStubModule;\n    }());\n    exports.NgxPermissionsModuleConfig = NgxPermissionsModuleConfig;\n    exports.NgxPermissionsModule = NgxPermissionsModule;\n    exports.NgxPermissionsAllowStubModule = NgxPermissionsAllowStubModule;\n    exports.NgxPermissionsRestrictStubModule = NgxPermissionsRestrictStubModule;\n    exports.NgxRolesStore = NgxRolesStore;\n    exports.NgxPermissionsStore = NgxPermissionsStore;\n    exports.NgxPermissionsConfigurationStore = NgxPermissionsConfigurationStore;\n    exports.NgxPermissionsDirective = NgxPermissionsDirective;\n    exports.USE_PERMISSIONS_STORE = USE_PERMISSIONS_STORE;\n    exports.NgxPermissionsService = NgxPermissionsService;\n    exports.USE_ROLES_STORE = USE_ROLES_STORE;\n    exports.NgxRolesService = NgxRolesService;\n    exports.USE_CONFIGURATION_STORE = USE_CONFIGURATION_STORE;\n    exports.NgxPermissionsConfigurationService = NgxPermissionsConfigurationService;\n    exports.NgxPermissionsGuard = NgxPermissionsGuard;\n    exports.NgxRole = NgxRole;\n    exports.NgxPermissionsAllowStubDirective = NgxPermissionsAllowStubDirective;\n    exports.NgxPermissionsRestrictStubDirective = NgxPermissionsRestrictStubDirective;\n    exports.NgxPermissionsPredefinedStrategies = NgxPermissionsPredefinedStrategies;\n    Object.defineProperty(exports, '__esModule', { value: true });\n})));\n",null]}